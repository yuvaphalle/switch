"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ALLOW_COMPONENT_DID_CATCH = exports.COMPONENT_SHOULD_BE_FUNCTION = void 0;
const pragma = "React";
const createClass = "createReactClass";
exports.COMPONENT_SHOULD_BE_FUNCTION = "componentShouldBeFunction";
exports.ALLOW_COMPONENT_DID_CATCH = "allowComponentDidCatch";
const COMPONENT_DID_CATCH = "componentDidCatch";
const PROGRAM_EXIT = "Program:exit";
function getComponentProperties(node) {
    switch (node.type) {
        case "ClassDeclaration":
        case "ClassExpression":
            return node.body.body;
        case "ObjectExpression":
            return node.properties;
        default:
            return [];
    }
}
function getPropertyNameNode(node) {
    if (node.key || ["MethodDefinition", "Property"].indexOf(node.type) !== -1) {
        return node.key;
    }
    if (node.type === "MemberExpression") {
        return node.property;
    }
    return undefined;
}
function getPropertyName(node) {
    const nameNode = getPropertyNameNode(node);
    return nameNode ? nameNode.name : "";
}
const rule = {
    meta: {
        docs: {
            description: "Enforce components are written as function components",
            category: "Stylistic Issues",
            recommended: false,
            suggestion: false,
            url: "https://github.com/tatethurston/eslint-plugin-react-prefer-function-component#rule-details",
        },
        type: "problem",
        messages: {
            [exports.COMPONENT_SHOULD_BE_FUNCTION]: "Class component should be written as a function",
        },
        schema: [
            {
                type: "object",
                properties: {
                    [exports.ALLOW_COMPONENT_DID_CATCH]: {
                        default: true,
                        type: "boolean",
                    },
                },
                additionalProperties: false,
            },
        ],
    },
    create(context) {
        var _a, _b;
        const allowComponentDidCatch = (_b = (_a = context.options[0]) === null || _a === void 0 ? void 0 : _a.allowComponentDidCatch) !== null && _b !== void 0 ? _b : true;
        const sourceCode = context.getSourceCode();
        function isES5Component(node) {
            if (!node.parent) {
                return false;
            }
            return new RegExp(`^(${pragma}\\.)?${createClass}$`).test(sourceCode.getText(node.parent.callee));
        }
        function isES6Component(node) {
            if (!node.superClass) {
                return false;
            }
            return new RegExp(`^(${pragma}\\.)?(Pure)?Component$`).test(sourceCode.getText(node.superClass));
        }
        function shouldPreferFunction(node) {
            if (!allowComponentDidCatch) {
                return true;
            }
            const properties = getComponentProperties(node).map(getPropertyName);
            return !properties.includes(COMPONENT_DID_CATCH);
        }
        const components = new Set();
        const detect = (guard) => (node) => {
            if (guard(node) && shouldPreferFunction(node)) {
                components.add(node);
            }
        };
        return {
            ObjectExpression: detect(isES5Component),
            ClassDeclaration: detect(isES6Component),
            ClassExpression: detect(isES6Component),
            [PROGRAM_EXIT]() {
                components.forEach((node) => {
                    context.report({
                        node,
                        messageId: exports.COMPONENT_SHOULD_BE_FUNCTION,
                    });
                });
            },
        };
    },
};
exports.default = rule;
